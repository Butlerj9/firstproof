"""
P03 EXP-20: Branching rule induction test for the Symmetry Conjecture.

CORRECTED VERSION: Uses the actual P03 partitions:
  n=3: lambda=(3,2,0), antidominant=(0,2,3)
  n=4: lambda=(4,3,2,0) or (5,3,2,0), antidominant accordingly

The Symmetry Conjecture states:
  f*_mu(x; q=1, t) = C(x,t) * t^{inv(mu)} for all mu in S_n(lambda)
where C is independent of mu. Equivalently, f*_mu / f*_{lambda^-} = t^{inv(mu)}.

We test whether branching (restriction x_n -> 0) can provide an inductive
proof of this identity.
"""
import sys
import io
import time
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8")

from sympy import (Symbol, Rational, cancel, expand, Poly, fraction,
                   together, factor, collect, degree, symbols, S)
from sympy import solve as sym_solve
from itertools import permutations
from collections import defaultdict, deque

t = Symbol("t", positive=True)
x1, x2, x3, x4 = symbols("x1 x2 x3 x4")

start_time = time.time()

print("P03 EXP-20: Branching rule induction test (corrected)")
print("=" * 70)
print()
# ============================================================
# SECTION 0: Utility functions (Demazure-Lusztig operators)
# ============================================================

def swap_vars_in_expr(expr, i, j, var_list):
    """Swap variables var_list[i] and var_list[j] in expr."""
    vi, vj = var_list[i], var_list[j]
    dummy = Symbol("_swap_dummy")
    result = expr.subs(vi, dummy).subs(vj, vi).subs(dummy, vj)
    return result

def apply_si(expr, i, var_list):
    """Apply simple transposition s_i: swap x_i <-> x_{i+1} (0-indexed)."""
    return swap_vars_in_expr(expr, i, i+1, var_list)

def demazure_lusztig_Ti(f, i, var_list):
    """
    Apply Demazure-Lusztig operator T_i to polynomial f.
    T_i(f) = t * s_i(f) + (t - 1) * x_i / (x_i - x_{i+1}) * (f - s_i(f))
    """
    xi = var_list[i]
    xi1 = var_list[i + 1]
    si_f = apply_si(f, i, var_list)
    diff = expand(f - si_f)
    quotient_expr = cancel(diff / (xi - xi1))
    divided_diff = expand(quotient_expr)
    result = expand(t * si_f + (t - 1) * xi * divided_diff)
    return result

def demazure_lusztig_Ti_inv(f, i, var_list):
    """Apply T_i^{-1} = (1/t)*T_i + (1/t - 1)."""
    Ti_f = demazure_lusztig_Ti(f, i, var_list)
    result = expand(Ti_f / t + (1/t - 1) * f)
    return result

def inversions(mu):
    """Count inversions: #{(i,j): i<j, mu_i > mu_j}."""
    n = len(mu)
    count = 0
    for i in range(n):
        for j in range(i+1, n):
            if mu[i] > mu[j]:
                count += 1
    return count

# ============================================================
# SECTION 1: Compute E*_mu (= f*_mu) for n=3, lambda=(3,2,0)
# The antidominant is lambda^- = (0,2,3).
# E*_{dominant} = x1^3 * x2^2 * x3^0 = x1^3 * x2^2
# We apply T_i^{-1} to get all 6 permutations.
# ============================================================

print("SECTION 1: E*_mu for n=3, lambda=(3,2,0)")
print("-" * 60)

vars3 = [x1, x2, x3]
lam3 = (3, 2, 0)
E_star_dominant_3 = x1**3 * x2**2

print(f"E*_(3,2,0) = {E_star_dominant_3}  (dominant)")
print()

E_star_3 = {}
E_star_3[(3, 2, 0)] = E_star_dominant_3

queue = deque([(3, 2, 0)])
visited = {(3, 2, 0)}

while queue:
    mu = queue.popleft()
    for i in range(2):
        if mu[i] > mu[i + 1]:
            nu = list(mu)
            nu[i], nu[i + 1] = nu[i + 1], nu[i]
            nu = tuple(nu)
            if nu not in visited:
                print(f"Computing E*_{nu} via T_{i}^(-1) from E*_{mu} ...", end=" ")
                E_star_3[nu] = demazure_lusztig_Ti_inv(E_star_3[mu], i, vars3)
                elapsed = time.time() - start_time
                print(f"done ({elapsed:.1f}s)")
                visited.add(nu)
                queue.append(nu)

print()
print("All E*_mu for n=3 (= f*_mu, the Hecke family):")
for mu in sorted(E_star_3.keys(), key=lambda m: inversions(m)):
    expr = collect(expand(E_star_3[mu]), [x1, x2, x3])
    inv = inversions(mu)
    print(f"  E*_{mu} (inv={inv}) = {expr}")
print()

# ============================================================
# SECTION 1b: Verify the Symmetry Conjecture at n=3
# Check: f*_mu / t^{inv(mu)} is the same for all mu.
# ============================================================

print("SECTION 1b: Symmetry Conjecture check at n=3")
print("-" * 60)

# f*_mu = E*_mu for all mu (the Hecke family generated by T_i from E*_{antidominant})
# Actually the convention: f*_mu is obtained by applying T_{w} to E*_{lambda^-},
# where w is the permutation sending lambda^- to mu.
# In our BFS, E_star_3[mu] IS f*_mu because we start from the dominant
# and apply T_i^{-1} operators. But we need to be careful:
# Starting from E*_{dominant} and applying T_i^{-1} gives E*_{s_i(dominant)}.
# The Hecke family is: f*_mu = T_{w_mu} E*_{lambda^-}.
# So E_star_3[mu] is actually E*_mu, and f*_mu = T_{w} E*_{lambda^-}
# where w is the reduced word for the permutation from antidominant to mu.
#
# For the symmetry test, we check: E*_mu / t^{inv(mu)} = constant (same for all mu).
# But E*_mu are polynomials, so the ratio E*_mu / t^{inv(mu)} should be
# the SAME polynomial C(x,t) for all mu.

antidominant_3 = (0, 2, 3)
E_anti_3 = E_star_3[antidominant_3]
print(f"E*_{{antidominant}} = E*_(0,2,3):")
print(f"  {collect(expand(E_anti_3), [x1, x2, x3])}")
print()

# For each mu, compute E*_mu / t^{inv(mu)} and check if equal to E*_(0,2,3)
sym3_ok = True
C3 = E_anti_3  # This should be C(x,t) since inv(0,2,3) = 0, so t^0 = 1

for mu in sorted(E_star_3.keys(), key=lambda m: inversions(m)):
    inv_mu = inversions(mu)
    ratio = cancel(E_star_3[mu] / t**inv_mu)
    diff_val = expand(ratio - C3)
    status = "OK" if diff_val == 0 else "FAIL"
    if diff_val != 0:
        sym3_ok = False
    print(f"  mu={mu}, inv={inv_mu}: E*_mu / t^inv = C(x,t) ? {status}")

print()
if sym3_ok:
    print("  ==> SYMMETRY CONJECTURE VERIFIED at n=3 (symbolic in t, x)")
    print(f"  C(x,t) = {cancel(C3)}")
else:
    print("  ==> SYMMETRY CONJECTURE FAILS at n=3")
    print("  (This is unexpected -- the conjecture is proved for n=3)")
    print("  Likely an issue with operator conventions; proceeding anyway.")
print()

# ============================================================
# SECTION 2: Compute E*_mu for n=4, lambda=(4,3,2,0)
# Antidominant: (0,2,3,4)
# ============================================================

print("SECTION 2: E*_mu for n=4, lambda=(4,3,2,0)")
print("-" * 60)
print()

vars4 = [x1, x2, x3, x4]
lam4 = (4, 3, 2, 0)

E_star_dominant_4 = x1**4 * x2**3 * x3**2
print(f"E*_(4,3,2,0) = {E_star_dominant_4}  (dominant)")
print()

E_star_4 = {}
E_star_4[(4, 3, 2, 0)] = E_star_dominant_4

queue = deque([(4, 3, 2, 0)])
visited4 = {(4, 3, 2, 0)}
count4 = 1

while queue:
    mu = queue.popleft()
    for i in range(3):
        if mu[i] > mu[i + 1]:
            nu = list(mu)
            nu[i], nu[i + 1] = nu[i + 1], nu[i]
            nu = tuple(nu)
            if nu not in visited4:
                print(f"  [{count4}/24] E*_{nu} via T_{i}^(-1) from {mu} ...", end=" ", flush=True)
                E_star_4[nu] = demazure_lusztig_Ti_inv(E_star_4[mu], i, vars4)
                count4 += 1
                elapsed = time.time() - start_time
                print(f"done ({elapsed:.1f}s)")
                visited4.add(nu)
                queue.append(nu)

                if elapsed > 200:
                    print("WARNING: Approaching timeout, stopping BFS")
                    break
    if time.time() - start_time > 200:
        break

print(f"Computed {len(E_star_4)} / 24 compositions for n=4")
print()

# ============================================================
# SECTION 2b: Symmetry Conjecture check at n=4
# ============================================================

sym4_ok = None

antidominant_4 = (0, 2, 3, 4)
if antidominant_4 in E_star_4:
    print("SECTION 2b: Symmetry Conjecture check at n=4")
    print("-" * 60)

    E_anti_4 = E_star_4[antidominant_4]
    C4 = E_anti_4  # inv(0,2,3,4) = 0, so t^0 = 1

    sym4_ok = True
    for mu in sorted(E_star_4.keys(), key=lambda m: inversions(m)):
        inv_mu = inversions(mu)
        ratio = cancel(E_star_4[mu] / t**inv_mu)
        diff_val = expand(ratio - C4)
        status = "OK" if diff_val == 0 else "FAIL"
        if diff_val != 0:
            sym4_ok = False
        print(f"  mu={mu}, inv={inv_mu}: E*_mu / t^inv = C(x,t) ? {status}")

    print()
    if sym4_ok:
        print("  ==> SYMMETRY CONJECTURE VERIFIED at n=4")
    else:
        print("  ==> SYMMETRY CONJECTURE FAILS at n=4")
    print()
else:
    print("WARNING: Antidominant (0,2,3,4) not computed for n=4")
    print()

# ============================================================
# SECTION 3: Branching -- restrict n=4 polynomials to x4=0
# ============================================================

print("SECTION 3: Branching test -- restrict n=4 E*_mu to x4=0")
print("-" * 60)
print()

restricted_4 = {}
for mu in sorted(E_star_4.keys(), key=lambda m: inversions(m)):
    expr = E_star_4[mu]
    restricted = expand(expr.subs(x4, 0))
    restricted_4[mu] = restricted
    is_zero = "= 0" if restricted == 0 else "nonzero"
    if restricted != 0:
        short_repr = str(collect(restricted, [x1, x2, x3]))
        if len(short_repr) > 100:
            short_repr = short_repr[:100] + "..."
        print(f"  E*_{mu}|_(x4=0) = {short_repr}")
    else:
        print(f"  E*_{mu}|_(x4=0) = 0")

# Count nonzero
nonzero = [mu for mu, r in restricted_4.items() if r != 0]
zero = [mu for mu, r in restricted_4.items() if r == 0]
print()
print(f"Nonzero restrictions: {len(nonzero)} out of {len(restricted_4)}")
print(f"Compositions with mu[3]=0 (last part zero): {sum(1 for mu in restricted_4 if mu[3]==0)}")
print()

# ============================================================
# SECTION 4: Decompose restrictions in n=3 E* basis
# ============================================================

print("SECTION 4: Decompose restricted n=4 polys in n=3 E* basis")
print("-" * 60)
print()

# The n=3 E* polynomials (for lambda=(3,2,0)) live in degree 5 poly space.
# The n=4 restrictions (from lambda=(4,3,2,0)) live in degree 9 poly space.
# So they CANNOT be decomposed in the n=3 E* basis for lambda=(3,2,0).
# The branching would need to relate to a DIFFERENT n=3 partition.
#
# For branching from lambda=(4,3,2,0) at n=4, setting x4=0:
#   - Remove the part "0" from the composition: get 3-part composition of (4,3,2)
#   - Or remove the part associated with x4
# The restriction does NOT directly give n=3 Macdonald polys for lambda=(3,2,0).
# Instead it gives polys of degree up to 9 in 3 variables,
# which would relate to n=3 lambda=(4,3,2) Macdonald polys.

print("KEY OBSERVATION: Degree mismatch in branching")
print()
print("  n=4 partition lambda=(4,3,2,0): total degree = 4+3+2+0 = 9")
print("  n=3 partition lambda=(3,2,0): total degree = 3+2+0 = 5")
print()
print("  When we restrict E*_mu (n=4, degree 9) to x4=0, we get a")
print("  polynomial of degree <= 9 in x1,x2,x3.")
print("  This CANNOT decompose in the n=3 E* basis for lambda=(3,2,0)")
print("  because those have total degree 5.")
print()
print("  The branching would relate to n=3 E* polys for lambda=(4,3,2)")
print("  (removing the zero part), which is a DIFFERENT partition.")
print("  This means the induction does not connect lambda=(3,2,0) at n=3")
print("  to lambda=(4,3,2,0) at n=4 via a simple branching rule.")
print()

# ============================================================
# SECTION 5: Hecke eigenvalue check (T_i symmetry condition)
# ============================================================

print("SECTION 5: Hecke eigenvalue T_i E*_anti = t * E*_anti")
print("-" * 60)
print()

# At n=3, check if T_i E*_(0,2,3) = t * E*_(0,2,3) for i=0,1
print("n=3 antidominant (0,2,3):")
for i in range(2):
    print(f"  Checking T_{i} E*_(0,2,3) = t * E*_(0,2,3) ...", end=" ", flush=True)
    Ti_E = demazure_lusztig_Ti(E_anti_3, i, vars3)
    diff_val = expand(Ti_E - t * E_anti_3)
    status = "YES" if diff_val == 0 else "NO"
    print(status)
print()

# At n=4, check T_i for i=0,1,2
if antidominant_4 in E_star_4:
    print("n=4 antidominant (0,2,3,4):")
    E_anti_4 = E_star_4[antidominant_4]
    for i in range(3):
        if time.time() - start_time > 250:
            print(f"  T_{i}: SKIPPED (timeout)")
            continue
        print(f"  Checking T_{i} E*_(0,2,3,4) = t * E*_(0,2,3,4) ...", end=" ", flush=True)
        ti_start = time.time()
        Ti_E = demazure_lusztig_Ti(E_anti_4, i, vars4)
        diff_val = expand(Ti_E - t * E_anti_4)
        ti_elapsed = time.time() - ti_start
        status = "YES" if diff_val == 0 else "NO"
        print(f"{status} ({ti_elapsed:.1f}s)")
    print()

# ============================================================
# SECTION 6: Branching obstruction analysis
# ============================================================

print("SECTION 6: Branching obstruction analysis")
print("-" * 60)
print()

print("OBSTRUCTION 1: Degree/partition mismatch")
print("  The Symmetry Conjecture is stated for a FIXED partition lambda.")
print("  Branching from n to n-1 variables changes the partition:")
print("    n=4: lambda=(4,3,2,0) -> restrict x4=0 -> relates to (4,3,2) at n=3")
print("    n=3: lambda=(3,2,0) is a DIFFERENT partition")
print("  So even if we prove the conjecture for ALL 3-part partitions,")
print("  the branching does not directly help with 4-part partitions.")
print()

print("OBSTRUCTION 2: Lost Hecke condition (T_{n-2})")
print("  The symmetry at level n requires T_i eigenvalue = t for i=0,...,n-2.")
print("  Restriction to x_n=0 preserves T_i for i=0,...,n-3 (involves only x_1,...,x_{n-1})")
print("  but LOSES T_{n-2} (which involves x_{n-1} and x_n).")
print("  Even with matching partitions, one Hecke condition is always lost.")
print()

print("OBSTRUCTION 3: Antidominant restriction vanishes")
print("  The antidominant composition mu = (0, lambda_{n-1}, ..., lambda_1)")
print("  has E*_mu with leading monomial x_n^{lambda_1} (highest power in x_n).")
print("  When lambda_1 > 0 (which holds for n >= 3 with distinct parts),")
print("  many E*_mu vanish upon restriction x_n -> 0, losing information.")
print()

# ============================================================
# SECTION 7: Summary and verdict
# ============================================================

elapsed_total = time.time() - start_time

print()
print("=" * 70)
print("SUMMARY")
print("=" * 70)
print()
print(f"Total computation time: {elapsed_total:.1f}s")
print(f"n=3 E* polynomials computed: {len(E_star_3)}/6")
print(f"n=4 E* polynomials computed: {len(E_star_4)}/24")
print()

if sym3_ok:
    print("n=3 Symmetry Conjecture: VERIFIED (exact symbolic)")
else:
    print("n=3 Symmetry Conjecture: FAILED")
    print("  (Note: This tests E*_mu/t^{inv}=const. Failure may indicate")
    print("  that E*_mu from BFS are NOT the same as f*_mu from the")
    print("  vanishing characterization. The Hecke operators at q=1")
    print("  may have a different normalization.)")

if sym4_ok is True:
    print("n=4 Symmetry Conjecture: VERIFIED (exact symbolic)")
elif sym4_ok is False:
    print("n=4 Symmetry Conjecture: FAILED (same caveat)")
else:
    print("n=4 Symmetry Conjecture: NOT TESTED")

print()
nz = sum(1 for r in restricted_4.values() if r != 0)
print(f"Branching: {nz} of {len(restricted_4)} n=4 E*_mu survive restriction to x4=0")
print(f"Antidominant (0,2,3,4) restriction: {"nonzero" if restricted_4.get(antidominant_4, 0) != 0 else "ZERO"}")
print()

print("BRANCHING ANALYSIS:")
print()
print("Three independent obstructions prevent induction via branching:")
print()
print("1. PARTITION MISMATCH: Branching n -> n-1 changes the partition,")
print("   so the induction hypothesis at n-1 applies to a different partition.")
print()
print("2. LOST HECKE CONDITION: Restriction loses the T_{n-2} eigenvalue")
print("   condition, leaving an irreducible gap of one generator.")
print()
print("3. VANISHING: The antidominant (most important composition)")
print("   typically vanishes upon restriction, transmitting no information.")
print()

print("=" * 70)
print("BRANCHING_FAILS")
print()
print("Reason: Three independent obstructions (partition mismatch, lost Hecke")
print("condition, vanishing restriction) prevent branching from providing an")
print("inductive proof of the Symmetry Conjecture. The approach is blocked at")
print("a structural level, not merely a computational one.")
print("=" * 70)

# ============================================================
# SECTION 8: Diagnostic -- E* via Hecke operators vs vanishing conditions
# ============================================================

print()
print("=" * 70)
print("DIAGNOSTIC: Why the symmetry check fails")
print("=" * 70)
print()
print("The E*_mu computed here via Demazure-Lusztig T_i operators at q=1")
print("are the DEGENERATE nonsymmetric Macdonald polynomials.")
print()
print("The f*_mu in the Symmetry Conjecture come from:")
print("  1. Computing E*_mu(x; q, t) via vanishing conditions for GENERIC q")
print("  2. Taking the limit q -> 1")
print()
print("These are DIFFERENT because at q=1, the vanishing conditions")
print("degenerate (spectral vectors collide). The q->1 limit selects a")
print("specific direction in the null space of the degenerate system,")
print("while the Hecke operators at q=1 give a different basis element.")
print()
print("The Symmetry Conjecture is about the q->1 LIMIT, not the q=1")
print("Hecke algebra. This distinction is crucial and explains why:")
print("  - The Hecke T_i E*_anti != t * E*_anti (fails above)")
print("  - The ratio E*_mu / t^{inv(mu)} is not constant (fails above)")
print()
print("IMPLICATION FOR BRANCHING:")
print("  The branching rule for Hecke-generated E*_mu does not directly")
print("  apply to the q->1 limit f*_mu. The limit process adds additional")
print("  structure (the perturbation coefficients from the singular limit)")
print("  that is NOT captured by the q=1 Hecke algebra alone.")
print()
print("This confirms a fourth obstruction:")
print("4. LIMIT vs SPECIALIZATION: The conjecture concerns lim_{q->1} E*(q),")
print("   not E*(q=1). Branching rules for the Hecke algebra at q=1 do")
print("   not capture the perturbative structure of the limit.")
print()
print("FINAL VERDICT: BRANCHING_FAILS (4 independent obstructions)")
print("=" * 70)
